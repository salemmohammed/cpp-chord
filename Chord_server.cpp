// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Node.h"
#include "Chord.h"
#include <math.h>
#include "sha1.h"
#include "Chord_Listener.h"
#include <string>
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <server/TThreadedServer.h>
#include <transport/TServerSocket.h>
#include <transport/TSocket.h>
#include <transport/TBufferTransports.h>
#include <iostream>
#include <stdio.h>
#include <vector>
#include <map>
#include <utility>
#include <boost/thread.hpp>

#define ME NULL
#define SUCCESSOR 0
#define NO_PREDECESSOR -1

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::mp2;
int _x;
bool debugging = false;;
int counter=0;


class ChordHandler : virtual public ChordIf {
 public:
  ChordHandler(int m = 5, int id = -1, int port = 9090, int introducer_port = -1,
      int s_interval = 2, int f_interval = 1) {
    _x = 0;
    this->m = m;
    this->introducer_port = introducer_port;
    this->id = id;
    this->port = port;
    this->pred.id = id;
    this->pred.port = port;
    this->stabilize_interval = s_interval;
    this->fix_interval = f_interval;
    //first element in table = successor
    this->finger_table = new vector<Node*>(m, NULL);
    int power = 1;
    power <<= m;
    this->power = power;
    this->gen_start_values();

    if(id != 0){
      shared_ptr<TSocket> socket(new TSocket("localhost", introducer_port));
      shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      this->introducer = new ChordClient(protocol);
      transport->open();
      successor returned;
      this->introducer->join_network(returned, this->id);
      printf("Introducer told me that my successor is %d on port %d\n", returned.id,
          returned.port);
      transport->close();
      printf("Returned: %d::%d\n", returned.id, returned.port);
      this->set_succ(returned.id, returned.port);
    }
    else{
      this->introducer = NULL;
    }

    pthread_mutex_init(&m_mutex, NULL);
    pthread_mutex_init(&transport_mutex, NULL);
    this->start();
  }

  void add_node() {
    // Your implementation goes here
    printf("RPC\n");
  }


  void add_file(key_and_node& _return, const std::string& filename, const std::string& data) {
    int key = generate_sha1(filename);
    //if we're the only node in the system,
    if(this->finger_table->at(SUCCESSOR) == NULL){
      data_store[key] = data;
      _return.node_id = this->id;
    }
    else{
    
    }
    _return.key = key;
  }

  void initiate_add_file(successor& _return, const std::string& filename, const std::string& data){

  }

  void del_file(key_and_node& _return, const std::string& filename) {
    int key = generate_sha1(filename);
    map<int, string>::iterator it = data_store.find(key);
    if(it != data_store.end()){
      //success
      if(this->finger_table->at(SUCCESSOR) == NULL){
        data_store.erase(it);
        _return.key = key;
        _return.node_id = this->id;
        _return.success = true;
      }
    }
    else{
      if(this->finger_table->at(SUCCESSOR) == NULL){
        _return.key = key;
        _return.node_id = this->id;
        _return.success = false;
      }
    }
  }


  void get_file() {
    // Your implementation goes here
    printf("get_file\n");
  }

  void get_table() {
    // Your implementation goes here
    printf("get_table\n");
  }

  void current_pred(predecessor& _return){
    //printf("Telling someone that my pred's id is %d\n", pred.id);
    _return.id = this->pred.id;
    _return.port = this->pred.port;
  }

  void notify(const int32_t pid, const int32_t new_port) {
    if(pid != this->id && (pred.id == this->id || in_range(pred.id, this->id, pid))){
      if(pred.id != pid){
        pred.id = pid;
        pred.port = new_port;
      }
    }
    else{
    }
  }

  //tell the introducer that we are joining
  //we can assume that add_node won't be called with an id that has alreayd 
  //been used
  void join_network(successor& _return, const int32_t pid){
    printf("Joining das network\n");
    this->find_successor(_return, pid);
  }

  void get_successor(successor& _return){
    _return.id = this->finger_table->at(0)->id;
    _return.port = this->finger_table->at(0)->port;
  }
  void find_successor(successor& _return, const int32_t pid) {
    neighbor returned;
    printf("Before find pred\n");
    this->find_predecessor(returned, pid);
    _return.id = returned.succ_id;
    _return.port = returned.succ_port;
    printf("End of find successor: %d::%d\n", _return.id, _return.port);
  }

  //this function isn't necessary right now, but we'll keep it
  //so that the code is consistent with the white paper
  void find_predecessor(neighbor& _return, const int32_t pid) {
    Node* cur;
    _return.id = this->id;
    _return.port = this->port;
    printf("Return value: %d::%d\n", _return.id, _return.port);
    if(this->finger_table->at(0) != NULL){
    _return.succ_id = this->finger_table->at(0)->id;
    _return.succ_port = this->finger_table->at(0)->port;
    printf("Return succ value: %d::%d\n", _return.succ_id, _return.succ_port);
    }
    else{
      _return.succ_id = this->id;
      _return.succ_port = this->port;
    printf("Return succ value: %d::%d\n", _return.succ_id, _return.succ_port);
    }
    while(!in_range(_return.id, _return.succ_id, pid)){
      printf("looping\n");
      cur = new Node(_return.id, _return.port);
      cur->open_connection();
      cur->connection->closest_preceding_finger(_return, pid);
      cur->close_connection();
    }
  }

  bool in_range(int left, int right, int t){
    bool returned;
    if(left > right){
      if(t >= left){
        return (t == left) || (t <= power);
      }
      else if (t <= right){
        return (t==right) || (t>= 0);
      }
    }
    else{
      returned = (t >= left) && (t <= right);
    }
    if(left == right) returned = true;

    _x++;
    return returned;
  }

  void closest_preceding_finger(neighbor& _return, const int32_t pid){
    int i = this->m-1;
    Node* entry;
    while(i>=0){
      entry = this->finger_table->at(i);
      if(entry == NULL && pid == this->id) break;
      if(entry != NULL && (this->in_range(this->id, pid, entry->id))){
        printf("inside of the loop\n");
        //pass to next node
        /*
        pthread_mutex_lock(&transport_mutex);
        printf("In mutex with %d;%d;%d\n", this->id, pid, entry->id);
        entry->open_connection();
        entry->connection->closest_preceding_finger(_return, pid);
        entry->close_connection();
        pthread_mutex_unlock(&transport_mutex);
        */

        printf("Finding prec finger\n");
        _return.id = entry->id;
        _return.port = entry->port;
        successor succ;
        entry->open_connection();
        entry->connection->get_successor(succ);
        entry->close_connection();
        _return.succ_id = succ.id;
        _return.succ_port = succ.port;
        return;
      }
      i--;
    }
    printf("outside of the loop\n");

    //current node is closest
    _return.id = this->get_id();
    _return.port = this->get_port();
    Node* curr = this->finger_table->at(SUCCESSOR);
    //case for first node - this node is its own successor
    if(curr == NULL){
      _return.succ_id = this->get_id();
      _return.succ_port = this->get_port();
    }
    else{
      _return.succ_id = curr->id;
      _return.succ_port = curr->port;
    }
  }

  void get_info(neighbor& _return){

  }

  //class functions
  bool is_introducer(){
    return (this->introducer_port != -1);
  } 
  int get_port(){
    return this->port;
  }

  int get_id(){
    return this->id;
  }

  //we'll make this just return the first element in our finger table
  int get_succ(){
    return 0;
  }
  
  void set_finger(int new_id, int new_port, int i){
    pthread_mutex_lock(&m_mutex);
    Node* curr = this->finger_table->at(i);
    if(curr != NULL){
      if(curr->id == new_id){
        pthread_mutex_unlock(&m_mutex);
        return;
      }
      else
        delete curr;
    }
    if(new_id == this->id){
      (*(this->finger_table))[i] = NULL;
    }
    else{
      (*(this->finger_table))[i] = new Node(new_id, new_port);
    }

    pthread_mutex_unlock(&m_mutex);
  }


  //manage connection here?
  void set_succ(int id, int port){
    printf("set succ %d::%d\n", id, port);
    Node* curr = this->finger_table->at(0);
    //no successor - either new node or the only node in the system!
    if(curr == NULL){
      pthread_mutex_lock(&m_mutex);
      (*(this->finger_table))[0] = new Node(id, port);
      pthread_mutex_unlock(&m_mutex);
    }
    else{
      //only do this stuff if it's a new node!
      if(curr->id != id){
        delete curr;
        pthread_mutex_lock(&m_mutex);
        (*(this->finger_table))[0] = new Node(id, port);
        pthread_mutex_unlock(&m_mutex);

        curr = this->finger_table->at(0);
        pthread_mutex_lock(&transport_mutex);
        curr->notify(this->id, this->port);
        pthread_mutex_lock(&transport_mutex);
      }
    }
  }


  void start(){
    pthread_create(&stabilize_thread, NULL, start_stabilize, this);
    pthread_create(&fix_thread, NULL, start_fix, this);
  }

  ChordClient* introducer;
  vector<Node*>* finger_table;
  int power;
  predecessor pred;
  //****
  map<int, string> data_store;

  //verify current node's successor
  //
  void gen_start_values(){
    start_values = new vector<int>(m+1, this->id);
    for(int i=0; i<=m; i++){
      (*(start_values))[i] = (this->id + (1 << (i))) % power;
    }
  }

  Node* atomic_get_node(int i){
    Node* returned;
    pthread_mutex_lock(&m_mutex);
    returned = this->finger_table->at(i);
    pthread_mutex_unlock(&m_mutex);
    return returned;
  }

  int generate_sha1(const string& input){
    SHA1Context sha;
    SHA1Reset(&sha);
    SHA1Input(&sha, (unsigned char*)input.c_str(), input.length());
    SHA1Result(&sha);
    int key_id = sha.Message_Digest[4]%(1<<m);
    return key_id;
  }

 private:
  int m;
  int id;
  int introducer_port;
  int port;
  int stabilize_interval;
  int fix_interval;
  pthread_t stabilize_thread;
  pthread_t fix_thread;
  pthread_mutex_t m_mutex;
  pthread_mutex_t transport_mutex;
  vector<int>* start_values;

  void stabilize(){
    Node* successor;
    predecessor next;
    while(true){
      sleep(this->stabilize_interval);
      printf("Before getting successor\n");
      successor = this->finger_table->at(SUCCESSOR);
      if(successor != NULL){
        printf("Iteration %d\n", counter);
        printf("My successor: %d\n", successor->id);
        printf("My predecessor: %d\n", pred.id);
        pthread_mutex_lock(&transport_mutex);
        successor->current_pred(next);
        pthread_mutex_unlock(&transport_mutex);
        //if our successor has no predecessor
        if(next.id != this->id && in_range(this->id, successor->id, next.id)){
          this->set_succ(next.id, next.port);
          successor = this->finger_table->at(SUCCESSOR);
        }
        pthread_mutex_lock(&transport_mutex);
        successor->notify(this->id, this->port);
        pthread_mutex_unlock(&transport_mutex);
      }
      else{
        if(pred.id != this->id){
          this->set_succ(pred.id, pred.port);
        }
      }
    }
  }

  void print_fingers(){
    printf("**********\n");
    printf("Fingers\n");
    Node* curr;
    for(int i=0; i<m; i++){
      curr = this->finger_table->at(i);
      if(curr == NULL)
        printf("%d : SELF\n", i);
      else
        printf("%d : %d\n", i, curr->id);
    }
    printf("**********\n");

  }

  void fix_fingers(){
    successor next;
    srand(time(NULL));
    int pick, curr_start;
    while(true){
      sleep(this->fix_interval);
      pick = rand() % (m-1) + 1;
      printf("Fixing fingers by looking at %dth start\n", pick);
      curr_start = this->start_values->at(pick);
      //printf("Start value at %d = %d\n", pick, curr_start);
        find_successor(next, curr_start);
        //printf("New finger is id: %d, port: %d at %d\n", next.id, next.port, pick);
      set_finger(next.id, next.port, pick);
      print_fingers();
    }
  }

  static void* start_stabilize(void* arg) {
    ChordHandler* h = reinterpret_cast<ChordHandler*>(arg);
    h->stabilize();
    pthread_exit(0);
  }

  static void* start_fix(void* arg){
    ChordHandler* h = reinterpret_cast<ChordHandler*>(arg);
    h->fix_fingers();
    pthread_exit(0);
  }

};

ChordHandler* init_node(int argc, char** argv){
  int id = -1;
  int port = -1;
  int m = -1;
  int introducer_port = -1;
  int num;
  int stabilize_interval = 2;
  int fix_interval = 1;

  cout << argc << endl;
  for(int i=0; i<argc; i++){
    //printf("%s\n", argv[i]);
  }

  for(int i=1; i<argc; i+=2){
    num = atoi(argv[i+1]);
    string arg = argv[i];
    if(arg == "--m"){
      //printf("M: %d\n", num);
      m = num;
    }
    else if(arg == "--id"){
      //printf("My id: %d\n", num);
      id = num;
    }
    else if(arg == "--port"){
      //printf("My port: %d\n", num);
      port = num;
    }
    else if (arg== "--introducerPort"){
      //printf("Intro port: %d\n", num);
      introducer_port = num;
    }
    else if (arg == "--stabilizeInterval"){
      //printf("Stab interval: %d\n", num);
      stabilize_interval = num;
    }
  }

  if(id != 0 && introducer_port == -1){
    std::cerr << "Need to include introducer port. Shutting down now." << endl;
    exit(1);
  }

  cout << "Successfully listening" << endl;
  return (new ChordHandler(m, id, port, introducer_port, stabilize_interval, fix_interval));
}

int main(int argc, char **argv) {
  ChordHandler* nodeh = init_node(argc, argv);
  shared_ptr<ChordHandler> handler(nodeh);
  shared_ptr<TProcessor> processor(new ChordProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(nodeh->get_port()));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TThreadedServer server(processor, serverTransport, transportFactory, protocolFactory);
  //printf("Starting session on port %d\n", nodeh->get_port());

  //spawn thread to take care of stabilization stuff
  
  server.serve();
  return 0;
}
